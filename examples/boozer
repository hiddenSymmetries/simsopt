#!/usr/bin/env python3
from simsopt.geo.biotsavart import BiotSavart
from simsopt.geo.magneticfieldclasses import InterpolatedField
# from simsopt.geo.surfacexyztensorfourier import SurfaceXYZTensorFourier
from simsopt.geo.boozersurface import BoozerSurface
from simsopt.geo.surfaceobjectives import boozer_surface_residual, ToroidalFlux, Area
from simsopt.geo.coilcollection import CoilCollection
import numpy as np
import sys
import os
sys.path.append(os.path.join("..", "tests", "geo"))
from surface_test_helpers import get_ncsx_data

"""
This example demonstrate how to compute surfaces in Boozer coordinates for a
magnetic field induced by coils.
We start with an initial guess that is just a tube around the magnetic axis,
then we reduce the Boozer residual with BFGS first, then drive it to machine
zero with a Levenberg-Marquardt algorithm. All of this is done while keeping
the surface area constant.  We then switch the label to the Toroidal Flux, and
aim for a Boozer surface with three times larger flux.
"""


coils, currents, ma = get_ncsx_data(Nt_coils=25, Nt_ma=10)
stellarator = CoilCollection(coils, currents, 3, True)
coils = stellarator.coils
currents = stellarator.currents
bs = BiotSavart(coils, currents)
bs.set_points(ma.gamma()[:10, :])
B = bs.B()
print(B)
# print(B.__array_interface__['data'])
dB = bs.dB_by_dX()
print(dB)
B = bs.B()
dB = bs.dB_by_dX()
print(B)
# print(B.__array_interface__['data'])

import sys; sys.exit()
import simsgeopp as sgpp

currents = [sgpp.Current(c) for c in currents]
coils = [sgpp.Coil(curve, current) for curve, current in zip(coils, currents)]
bspp = sgpp.BiotSavart(coils)
bspp.set_points(ma.gamma())
print(bspp.B())
print(bspp.dB_by_dX())
# bspp.invalidate_cache()
# d = coils[0].get_dofs()
# coils[0].set_dofs(d*2)
# print(bspp.B())
import IPython; IPython.embed()
import sys; sys.exit()


print(ma.gamma().shape)

n = 12
bsh = InterpolatedField(bs, order=4, rmin=1.3, rmax=1.7, rsteps=n, phimin=0, phimax=2*np.pi, phisteps=n*32, zmin=-0.1, zmax=0.1, zsteps=n)
print('Error =', bsh.estimate_error())
Bh = bsh.set_points(ma.gamma()).B()
B = bs.set_points(ma.gamma()).B()
N = int(1e2)
import time
t1 = time.time()
for i in range(N):
    Bh = bsh.set_points(ma.gamma()).B()
t2 = time.time()
for i in range(N):
    B = bs.set_points(ma.gamma()).B()
t3 = time.time()
print('Time for interpolation =', t2-t1)
print('Time for Biot Savart   =', t3-t2)
print('Speedup                =', (t3-t2)/(t2-t1))
print(np.linalg.norm(Bh-B))
import sys; sys.exit()

rmin = 1.5
rmax = 1.7
phimin = 0.
phimax = 2*np.pi
zmin = -0.1
zmax = +0.1
def bsfun(r, phi, z):
    x = r * np.cos(phi)
    y = r * np.sin(phi)
    return bs.set_points(np.asarray([[x, y, z]])).B()[0, :]
def bsfunbatch(r, phi, z):
    r = np.asarray(r)
    phi = np.asarray(phi)
    z = np.asarray(z)
    # r = rmin + r * (rmax-rmin)
    # phi = phimin + phi * (phimax-phimin)
    # z = zmin + z * (zmax-zmin)
    x = r * np.cos(phi)
    y = r * np.sin(phi)
    return bs.set_points(np.vstack((x, y, z)).T).B().flatten()


n = 4
bsh = sgpp.RegularGridInterpolant3D4((rmin, rmax, n), (phimin, phimax, n*64), (zmin, zmax, n), 3)
bsh.interpolate_batch(bsfunbatch)
print(bsh.estimate_error(bsfun, 1000))
xyz = np.random.uniform(size=(N, 3))
xyz[:, 0] = rmin + xyz[:, 0]*(rmax-rmin)
xyz[:, 1] = phimin + xyz[:, 1]*(phimax-phimin)
xyz[:, 2] = zmin + xyz[:, 2]*(zmax-zmin)
import time
t1 = time.time()
for i in range(N):
    bsfun(xyz[i, 0], xyz[i, 1], xyz[i, 2])
t2 = time.time()
for i in range(N):
    bsh.evaluate(xyz[i, 0], xyz[i, 1], xyz[i, 2])
t3 = time.time()
print(t2-t1)
print(t3-t2)

# bsh.interpolate(bsfun)



# import IPython; IPython.embed()
import sys; sys.exit()
bs_tf = BiotSavart(coils, currents)
G0 = 2. * np.pi * np.sum(np.abs(bs.coil_currents)) * (4 * np.pi * 10**(-7) / (2 * np.pi))

mpol = 5  # try increasing this to 8 or 10 for smoother surfaces
ntor = 5  # try increasing this to 8 or 10 for smoother surfaces
stellsym = True
nfp = 3

phis = np.linspace(0, 1/nfp, 2*ntor+1, endpoint=False)
thetas = np.linspace(0, 1, 2*mpol+1, endpoint=False)
s = SurfaceXYZTensorFourier(
    mpol=mpol, ntor=ntor, stellsym=stellsym, nfp=nfp, quadpoints_phi=phis, quadpoints_theta=thetas)
s.fit_to_curve(ma, 0.10, flip_theta=True)
iota = -0.4

tf = ToroidalFlux(s, bs_tf)
ar = Area(s)
ar_target = ar.J()

boozer_surface = BoozerSurface(bs, s, ar, ar_target)

# compute surface first using LBFGS, this will just be a rough initial guess
res = boozer_surface.minimize_boozer_penalty_constraints_LBFGS(tol=1e-10, maxiter=300, constraint_weight=100., iota=iota, G=G0)
print(f"iota={res['iota']:.3f}, tf={tf.J():.3f}, area={s.area():.3f}, ||residual||={np.linalg.norm(boozer_surface_residual(s, res['iota'], res['G'], bs, derivatives=0)):.3e}")
if "DISPLAY" in os.environ:
    s.plot()
# now drive the residual down using a specialised least squares algorithm
res = boozer_surface.minimize_boozer_penalty_constraints_ls(tol=1e-10, maxiter=100, constraint_weight=100., iota=res['iota'], G=res['G'], method='manual')
print(f"iota={res['iota']:.3f}, tf={tf.J():.3f}, area={s.area():.3f}, ||residual||={np.linalg.norm(boozer_surface_residual(s, res['iota'], res['G'], bs, derivatives=0)):.3e}")
if "DISPLAY" in os.environ:
    s.plot()


# change the label of the surface to toroidal flux and aim for a surface with triple the flux
tf_target = 3 * tf.J()
boozer_surface = BoozerSurface(bs, s, tf, tf_target)

res = boozer_surface.minimize_boozer_penalty_constraints_ls(tol=1e-10, maxiter=100, constraint_weight=100., iota=res['iota'], G=res['G'], method='manual')
print(f"iota={res['iota']:.3f}, tf={tf.J():.3f}, area={s.area():.3f}, ||residual||={np.linalg.norm(boozer_surface_residual(s, res['iota'], res['G'], bs, derivatives=0)):.3e}")
if "DISPLAY" in os.environ:
    s.plot()
