import numpy as np
import scipy as sp
from scipy.fft import rfft
import simsoptpp as sopp
from .magneticfield import MagneticField
from simsopt.geo import SurfaceRZFourier, CurveXYZFourier, RotatedCurve
from simsopt.field import Coil, Current
from simsopt.field.coil import ScaledCurrent

mu0 = 4.0*np.pi*1e-7

__all__ = ['WireframeField', 'coils_from_wireframe', 'enclosed_current']


class WireframeField(sopp.WireframeField, MagneticField):
    """
    Computes the magnetic field generated by currents in a wireframe grid.

    Parameters
    ----------
        wframe: instance of a ToroidalWireframe class

    """

    def __init__(self, wframe):

        sopp.WireframeField.__init__(self, wframe.nodes, wframe.segments,
                                     wframe.seg_signs, wframe.currents)
        MagneticField.__init__(self)
        self.wireframe = wframe

    def dB_by_dsegmentcurrents(self, compute_derivatives):
        """
        Calculates the derivative of the magnetic field or its spatial 
        derivatives at each field reference point with respect to the current
        in each wireframe segment.

        Parameters
        ----------
            compute_derivatives: integer (must be 0 or 1)
                If zero, will provide derivatives of the magnetic field with
                respect to segment currents. If one, will provide derivatives
                of the first spatial derivatives of the magnetic field with
                respect to segment currents.

        Returns
        -------
            dB_by_dsegmentcurrents: list of arrays
                Arrays of the requested derivatives, including one array for
                each segment in the wireframe.
        """

        points = self.get_points_cart_ref()
        n_points = len(points)
        if any([not self.fieldcache_get_status(f'B_{i}')
                for i in range(self.wireframe.n_segments)]):
            assert compute_derivatives >= 0
            self.compute(compute_derivatives)

        self._dB_by_dcoilcurrents = \
            [self.fieldcache_get_or_create(f'B_{i}', [n_points, 3])
             for i in range(self.wireframe.n_segments)]
        return self._dB_by_dcoilcurrents

    def dBnormal_by_dsegmentcurrents_matrix(self, surface, area_weighted=False):
        """
        Generates a matrix with derivatives of normal magnetic field on a
        surface of interest with respect to the current in each wireframe
        segment, useful for optimization of the segment currents.

        Parameters
        ----------
            surface: Surface class instance
                Surface on which to calculate the magnetic field. It is assumed
                that the quadrature points are evenly spaced in the toroidal
                and poloidal angles, and that they cover a whole number of
                half-periods.
            area_weighted: logical (optional)
                If true, will multiply each matrix element by the square root
                of the surface area ascribed to the corresponding quadrature 
                point. In this way, the expression (A*x)^2 gives the surface
                integral of the squared flux, where A is the matrix with 
                weighted elements and x is a vector with the currents in each 
                wireframe segment. Default is False.
        """

        points = self.get_points_cart_ref()
        n_points = len(points)

        if not isinstance(surface, SurfaceRZFourier):
            raise ValueError('Surface must be a SurfaceRZFourier object')

        n = surface.normal()
        absn = np.linalg.norm(n, axis=2)
        unitn = n * (1. / absn)[:, :, None]

        if area_weighted:
            fac = np.sqrt(absn/float(absn.size))
        else:
            fac = np.ones(absn.shape)

        matrix = np.ascontiguousarray(
            np.zeros((n_points, self.wireframe.n_segments)))
        dB_dsc = self.dB_by_dsegmentcurrents(0)
        for i in range(self.wireframe.n_segments):
            dB_dsc_i = dB_dsc[i].reshape(n.shape)
            matrix[:, i] = (fac*np.sum(dB_dsc_i * unitn, axis=2)).reshape((-1))

        return matrix

def coils_from_wireframe(wf, max_order=20, min_order=2, ppp=20):
    """
    Generates `~simsopt.field.Coil` class instances using the 
    :obj:`~simsopt.geo.CurveXYZFourier` class to represent the geometry of 
    coils identified within the wireframe. 
    The :obj:`~simsopt.geo.CurveXYZFourier` space curves are fit to the 
    nodes that each wireframe-based coil passes through. Only works if 
    there are no current crossings in the wireframe.

    Parameters
    ----------
        wf: wireframe class instance
            Wireframe from which coils are to be determined
        max_order: integer (optional)
            Maximum mode order for Fourier series approximations of the
            coil curves. Actual order for a given coil may be lower if it 
            has a small number of wireframe nodes (unless the `min_order` 
            parameter is used to enforce a minimum order). Default is 20.
        min_order: integer (optional)
            Minimum mode order for Fourier series approximations of the
            coil curves.
        ppp: integer (optional)
            Number of quadrature points to assign per period for the 
            highest-order Fourier harmonic for the curve of each coil

    Returns
    -------
        coils: list of Coil class instances
            :obj:`~simsopt.field.Coil` class instances corresponding to
            each coil found within the wireframe. Coils constrained to
            have like currents and geometry by stellarator symmetry share
            their respective degrees of freedom.
    """

    # Obtain the current flows in the wireframe forming coils
    coords_all, curr_all, group_ids = \
        wf.find_coils(repeat_starting_points=False)

    this_group = -1
    base_ind = -1
    first_in_group = True

    n_coils = len(curr_all)
    coils = []

    for i in range(n_coils):

        # Determine whether the coil is the first in its group
        if group_ids[i] != this_group:
            first_in_group = True
            this_group = group_ids[i]
        else:
            first_in_group = False

        # Generate a new coil
        if first_in_group:

            n_nodes = coords_all[i].shape[0]

            # If not enough nodes to support minimum order, add points at
            # midpoints between existing nodes
            coords = np.array(coords_all[i])
            while n_nodes < 2 * min_order:
               coords_prev = np.array(coords)
               coords = np.zeros((2*coords_prev.shape[0], 3))
               coords[::2, :] = coords_prev
               coords[1::2, :] = \
                   0.5 * (coords_prev + np.roll(coords_prev, -1, axis=0))
               n_nodes = coords.shape[0]

            order = min(int(n_nodes/2), max_order) 

            all_coeffs = []

            # Compute the Fourier coefficients
            for x in [coords[:, 0], coords[:, 1], coords[:, 2]]:

                xf = rfft(x) / len(x)

                fft_0 = [xf[0].real]                # 0 order coefficient
                fft_cos = 2 * xf[1:order + 1].real  # cosine coefficients
                fft_sin = -2 * xf[:order + 1].imag  # sine coefficients

                combined_fft = np.concatenate([fft_sin, fft_0, fft_cos])
                all_coeffs.append(combined_fft)

            all_coeffs = np.concatenate(all_coeffs).reshape(6, order+1).T

            # Initialize a curve and set its degress of freedom
            curve = CurveXYZFourier(order*ppp, order)
            dofs = curve.dofs_matrix
            dofs[0][0] = all_coeffs[0, 1]
            dofs[1][0] = all_coeffs[0, 3]
            dofs[2][0] = all_coeffs[0, 5]
            for io in range(order):
                dofs[0][2*io+1] = all_coeffs[io+1, 0]
                dofs[0][2*io+2] = all_coeffs[io+1, 1]
                dofs[1][2*io+1] = all_coeffs[io+1, 2]
                dofs[1][2*io+2] = all_coeffs[io+1, 3]
                dofs[2][2*io+1] = all_coeffs[io+1, 4]
                dofs[2][2*io+2] = all_coeffs[io+1, 5]

            curve.local_x = np.concatenate(dofs)

            coils.append(Coil(curve, Current(curr_all[i])))

            base_ind = i

        # Create a scaled/rotated curve that best fits the current coil
        else:

            # Calculate curve points roughly corresponding to nodes
            n_qpts = len(curve.quadpoints)
            n_nodes = coords_all[i].shape[0]
            qpt_inds = (np.arange(n_nodes)/(n_nodes)*n_qpts).astype(int)
            curve_pts = coils[base_ind].curve.gamma()[qpt_inds, :]

            coords = coords_all[i]
            coords_flip = np.roll(coords, -1, axis=0)[::-1, :]

            resid2 = np.zeros((2*wf.nfp))

            # Calculate residuals with nodes for different rotations/flips
            for i in range(wf.nfp):

                phi = i * 2 * np.pi / wf.nfp
                rotmat = np.asarray([[np.cos(phi), -np.sin(phi), 0],
                                     [np.sin(phi),  np.cos(phi), 0],
                                     [       0,         0, 1]]).T
                rotmat_flip = rotmat @ np.asarray([[1,  0,  0],
                                                   [0, -1,  0],
                                                   [0,  0, -1]])

                resid2[i] = np.sum((curve_pts @ rotmat - coords)**2)
                resid2[wf.nfp+i] = \
                    np.sum((curve_pts @ rotmat_flip - coords_flip)**2)

            # Identify the rotation/flip with the lowest residual
            imin = np.argmin(resid2)
            flip = imin >= wf.nfp
            phi_best = np.mod(imin, wf.nfp) * 2 * np.pi / wf.nfp

            curve = RotatedCurve(coils[base_ind].curve, phi_best, flip)
            if flip:
                current = ScaledCurrent(coils[base_ind].current, -1)
            else:
                current = coils[base_ind].current

            coils.append(Coil(curve, current))

    return coils


def enclosed_current(curve, field, n_quadpoints, preserve_points=True):
    """
    Calculates the integral of a vector field along a curve in 3D space.
    Useful for tests to verify consistency of wireframe solutions with their
    constraints.

    Parameters
    ----------
        curve: CurveXYZFourier class instance
            Curve along which the integral is to be taken. The more quadrature
            points the curve has, the greater precision the result will have.
        field: MagneticField class instance
            Magnetic field in which the curve is integrated.
        n_quadpoints: integer
            Number of quadrature points for the integral.
        preserve_points: boolean
            If true, the existing field points of `field` will be restored 
            before the function returns. If false, the field points will be
            changed to the quadrature points for integration. Default is true. 
            Setting to false may save time.

    Returns
    -------
        integral: double
            Integral of the magnetic field along the curve.
    """

    if not isinstance(curve, CurveXYZFourier):
        raise ValueError('curve must be an instance of the '
                         + 'CurveXYZFourier class')

    if not isinstance(field, MagneticField):
        raise ValueError('field must be an instance of the MagneticField class')

    # Make a copy of the input Curve
    _curve = CurveXYZFourier(np.linspace(0, 1, n_quadpoints), curve.order,
                             dofs=curve.dofs)

    # Obtain the field vectors along the curve
    if preserve_points:
        original_field_points = field.get_points_cart_ref()

    # Set the field points equal to the curve's quadrature points
    field.set_points(_curve.gamma())
    field_on_curve = field.B()

    if preserve_points:
        field.set_points(original_field_points)

    abs_tangent = np.linalg.norm(_curve.gammadash(), axis=1).reshape((-1, 1))
    unit_tangent = _curve.gammadash()/abs_tangent

    # Find the projection of the field onto the curve tangent vector
    B_dot_unit_tangent = np.sum(field_on_curve*unit_tangent, axis=1)

    # Estimate the cumulative arc length
    inc_arc = _curve.incremental_arclength()
    midpoint_inc_arc = 0.5*(inc_arc[:-1] + inc_arc[1:])
    delta_arclength = np.diff(_curve.quadpoints)*midpoint_inc_arc
    arclength = np.concatenate(([0], np.cumsum(delta_arclength)))

    return sp.integrate.simpson(B_dot_unit_tangent, x=arclength)/mu0
